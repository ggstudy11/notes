### 什么是JVM
jvm本质是一个运行在计算机上的程序，他的职责是运行java字节码文件  

### JVM的功能
- 解释和运行，对字节码文件中的指令实时的解释成机器码，让计算机执行
- 内存管理，自动为对象、方法等分配内存，自动的垃圾回收机制，回收不再使用的对象
- 即时编译，对热点代码进行优化，提升执行效率

### JVM的功能-即时编译
- java语言如果不做任何优化，性能不如c、c++语言
- java需要实时解释，主要是为了支持跨平台特性


即时编译的实现：  
如果一段代码被多次执行，jvm就会认为这是一段热点代码，因此将该代码解释成机器码后存入内存，方便下一次调用。

### Java虚拟机的组成

- 类加载器，加载字节码文件
- 运行时的数据区域(JVM管理的内存)
- 执行引擎(即时编译器、解释器、垃圾回收器)
- 本地接口(调用本地已经编译的方法，比如虚拟机中提供的c/c++方法)

### 认识字节码文件
- 基础信息：魔数、字节码文件对应的java版本号访问标识、父类与接口
- 常量池：保存了字符串常量、类或接口名、字段名主要在字节码指令中使用
- 字段：当前类或接口声明的字段信息
- 方法：当前类或接口的方法信息
- 属性：类的属性。比如源码的文件名内部类的列表

**Magic魔数**
- 文件是无法通过文件拓展名来确定文件类型的，文件拓展名可以随意修改，不影响文件内容
- 软件使用文件的头几个字节去校验文件的类型，如果软件不支持该种类型就会出错
- Java字节码文件的前四个字节必须是CAFEBABE

### 案例
解决由于主版本号不兼容导致的错误：  
类文件具有错误的版本52.0，应为50.0... 版本号- 44就是JDK版本 这里就是JDK8
，解决方案：1. 升级JDK版本(显然不推荐) 2. 将第三方依赖的版本号降低或者更换依赖

### 常量池
- 字节码文件中常量池的作用：避免相同的内容重复定义，节省空间

**为什么字节码要先存string类型，才存字面量的引用呢？**
1. 常量池的字符串必须要保留，因为要加载到字符串常量中
2. 字面量要保存，因为可能用到字符串，也可能用到字段名上
3. 可以理解为常量池的字符串是给了一个标识，字面量的存放是存了具体的值

- 常量池的数据都有一个编号，编号从1开始。在字段或者字节码指令中可以通过编号快速找到对应的数据
- 字节码指令通过编号引用到常量池的过程称之为符号引用

### 方法
- 操作数栈是临时存放数据的地方，局部变量表是存放中的局部变量的位置  
举个例子：  
int i = 0； int j = i + 1；这段代码是如何执行的呢？
首先介绍几个字节码指令：
- iconst 代表放入操作数栈某个数
- istore 代表将操作数栈的数存入局部变量表
- iload 代表从局部变量表中取出数放入操作数栈中
- iadd 代表将操作数栈中两个数相加

因此上述代码的流程应该是：iconst_0 -> istore_1 -> iload_1 -> iconst_1 -> iadd -> istore_2 -> return

分析：int i = 0; i = i ++;  
- iconst_0
- istore_1
- iload_1
- iinc 1 by 1(这里注意的是直接在局部变量表数组中加1)
- istore_1
- return

因此还是为0

### 类的生命周期
类的声明周期描述了一个类加载、使用、卸载的整个过程  
五个阶段
- 加载
- 连接
- 初始化
- 使用
- 卸载

### 加载阶段
1. 加载阶段的第一步是类加载器根据类的全限定名通过不同渠道以二进制流获取字节码信息
2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中
3. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息
4. 同时，Java虚拟机还会在堆中生成一份与方法去中数据类似的java.lang.class对象，作用是在Java代码中获取类的信息以及存储静态字段的数据

为什么需要在方法区和堆区都要存储数据，因为方法区一般是c语言编写的无法直接操作，在堆区是java进行封装后了的，同时对于开发者而言，只需要访问堆中的Class对象而不需要访问方法区中的所有信息，这样Java虚拟机就能很好的控制访问。

### 连接阶段
1. 验证，验证内容是否满足<<Java虚拟机规范>>，该阶段一般不需要程序员参与
2. 准备，给静态静态变量赋值处置，会给堆区中分配内存并设置初始值(默认值而不是程序中的设定值)，但是如果给定了final就不一样，直接赋值。
3. 解析，将常量池中的符号引用替换成直接引用，直接引用不再使用编号，而是使用内存中的地址访问具体的地址

### 初始化阶段
- 初始化阶段会执行静态代码块中的代码，并为静态变量赋值
- 初始化阶段会执行字节码文件中clinit部分的字节码指令

几种触发类初始化的几种方式：
1. 访问一个类的静态变量或者是静态方法，但如果变量被final修饰并且等号右边是常量不会触发初始化(因为这是在链接阶段)
2. 调用Class.forName(String className)
3. new一个该类的对象时
4. 执行Main方法的当前类  

clinit指令在特定情况下不会出现，比如，如下好几种情况是不会进行初始化指令执行的。
1. 无静态代码块且无静态变量赋值语句
2. 有静态变量的声明，但是没有赋值语句
3. 静态变量的定义使用final关键字，这类变量会在准备阶段直接初始化

- 直接访问父类的静态变量，不会触发子类的初始化
- 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法
- 对于引用数据类型的数组，JVM分配的内存只是用来存储对象引用的，这些引用初始都为null，所以不会触发对象的创建
- 如果final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。
