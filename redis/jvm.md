### 什么是JVM
jvm本质是一个运行在计算机上的程序，他的职责是运行java字节码文件  

### JVM的功能
- 解释和运行，对字节码文件中的指令实时的解释成机器码，让计算机执行
- 内存管理，自动为对象、方法等分配内存，自动的垃圾回收机制，回收不再使用的对象
- 即时编译，对热点代码进行优化，提升执行效率

### JVM的功能-即时编译
- java语言如果不做任何优化，性能不如c、c++语言
- java需要实时解释，主要是为了支持跨平台特性


即时编译的实现：  
如果一段代码被多次执行，jvm就会认为这是一段热点代码，因此将该代码解释成机器码后存入内存，方便下一次调用。

### Java虚拟机的组成

- 类加载器，加载字节码文件
- 运行时的数据区域(JVM管理的内存)
- 执行引擎(即时编译器、解释器、垃圾回收器)
- 本地接口(调用本地已经编译的方法，比如虚拟机中提供的c/c++方法)

### 认识字节码文件
- 基础信息：魔数、字节码文件对应的java版本号访问标识、父类与接口
- 常量池：保存了字符串常量、类或接口名、字段名主要在字节码指令中使用
- 字段：当前类或接口声明的字段信息
- 方法：当前类或接口的方法信息
- 属性：类的属性。比如源码的文件名内部类的列表

**Magic魔数**
- 文件是无法通过文件拓展名来确定文件类型的，文件拓展名可以随意修改，不影响文件内容
- 软件使用文件的头几个字节去校验文件的类型，如果软件不支持该种类型就会出错
- Java字节码文件的前四个字节必须是CAFEBABE

### 案例
解决由于主版本号不兼容导致的错误：  
类文件具有错误的版本52.0，应为50.0... 版本号- 44就是JDK版本 这里就是JDK8
，解决方案：1. 升级JDK版本(显然不推荐) 2. 将第三方依赖的版本号降低或者更换依赖

### 常量池
- 字节码文件中常量池的作用：避免相同的内容重复定义，节省空间

**为什么字节码要先存string类型，才存字面量的引用呢？**
1. 常量池的字符串必须要保留，因为要加载到字符串常量中
2. 字面量要保存，因为可能用到字符串，也可能用到字段名上
3. 可以理解为常量池的字符串是给了一个标识，字面量的存放是存了具体的值

- 常量池的数据都有一个编号，编号从1开始。在字段或者字节码指令中可以通过编号快速找到对应的数据
- 字节码指令通过编号引用到常量池的过程称之为符号引用

### 方法
- 操作数栈是临时存放数据的地方，局部变量表是存放中的局部变量的位置  
举个例子：  
int i = 0； int j = i + 1；这段代码是如何执行的呢？
首先介绍几个字节码指令：
- iconst 代表放入操作数栈某个数
- istore 代表将操作数栈的数存入局部变量表
- iload 代表从局部变量表中取出数放入操作数栈中
- iadd 代表将操作数栈中两个数相加

因此上述代码的流程应该是：iconst_0 -> istore_1 -> iload_1 -> iconst_1 -> iadd -> istore_2 -> return

分析：int i = 0; i = i ++;  
- iconst_0
- istore_1
- iload_1
- iinc 1 by 1(这里注意的是直接在局部变量表数组中加1)
- istore_1
- return

因此还是为0

### 类的生命周期
类的声明周期描述了一个类加载、使用、卸载的整个过程  
五个阶段
- 加载
- 连接
- 初始化
- 使用
- 卸载

### 加载阶段
1. 加载阶段的第一步是类加载器根据类的全限定名通过不同渠道以二进制流获取字节码信息
2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中
3. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息
4. 同时，Java虚拟机还会在堆中生成一份与方法去中数据类似的java.lang.class对象，作用是在Java代码中获取类的信息以及存储静态字段的数据

为什么需要在方法区和堆区都要存储数据，因为方法区一般是c语言编写的无法直接操作，在堆区是java进行封装后了的，同时对于开发者而言，只需要访问堆中的Class对象而不需要访问方法区中的所有信息，这样Java虚拟机就能很好的控制访问。

### 连接阶段
1. 验证，验证内容是否满足<<Java虚拟机规范>>，该阶段一般不需要程序员参与
2. 准备，给静态静态变量赋值处置，会给堆区中分配内存并设置初始值(默认值而不是程序中的设定值)，但是如果给定了final就不一样，直接赋值。
3. 解析，将常量池中的符号引用替换成直接引用，直接引用不再使用编号，而是使用内存中的地址访问具体的地址

### 初始化阶段
- 初始化阶段会执行静态代码块中的代码，并为静态变量赋值
- 初始化阶段会执行字节码文件中clinit部分的字节码指令

几种触发类初始化的几种方式：
1. 访问一个类的静态变量或者是静态方法，但如果变量被final修饰并且等号右边是常量不会触发初始化(因为这是在链接阶段)
2. 调用Class.forName(String className)
3. new一个该类的对象时
4. 执行Main方法的当前类  

clinit指令在特定情况下不会出现，比如，如下好几种情况是不会进行初始化指令执行的。
1. 无静态代码块且无静态变量赋值语句
2. 有静态变量的声明，但是没有赋值语句
3. 静态变量的定义使用final关键字，这类变量会在准备阶段直接初始化

- 直接访问父类的静态变量，不会触发子类的初始化
- 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法
- 对于引用数据类型的数组，JVM分配的内存只是用来存储对象引用的，这些引用初始都为null，所以不会触发对象的创建
- 如果final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。

### 什么是类加载器
- 类加载器是Java虚拟机提供给应用程序区获取类和接口字节码数据的技术，只参与加载过程中字节码获取并加载到内存这一块(然后进行本地接口嗲用，调用其他语言的接口)

### 类加载器的应用场景

- SPI机制
- 类的热部署
- Tomcat类的隔离
- 类的双亲委派机制
- 打破类的双亲委派机制
- 自定义类加载器
- 使用Arthas不停机解决线上故障

### 类加载器的分类
类加载器分为两类，一类是Java代码实现，一类是Java虚拟机底层源码实现
- 虚拟机底层实现，源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如HotSpot使用c++，保证java程序运行中基础类正确地加载
- Java实现，JDK默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，都继承了虚拟类classloader

**JDK8之前版本默认的加载器：**
1. 虚拟机底层实现：加载Java中最核心的类(启动类加载器Bootstrap)
2. Java实现: 扩展类加载器Extension允许拓展Java中比较通用的类，应用程序类加载器：Application

### 启动类加载器
- 启动类加载器是由Hotspot虚拟机提供的，使用C++编写的类加载器。默认加载Java安装目录/jre/lib下的类文件，比如rt.jar等

**通过启动类加载用户jar包**
- 放入jre/lib下进行拓展，不推荐，尽可能不去更改JDK安装目录中的内容，会出现即使放进去也可能由于文件名不匹配的问题也不会正常的被加载
- 使用参数进行推展，推荐，使用-Xbootchasspath/a:jar包目录/jar包名进行拓展

### 拓展类加载器和应用程序加载器
- 都是JDK提供的，使用Java编写的类加载器
- 它们的源码都位于sun.misc.Launcher中，是一个静态内部类，继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中

### 扩展类加载器
- 扩展类加载器是JDK提供的，使用Java编写的类加载器
- 默认加载Java安装目录/jre/lib/ext下的类文件

**通过扩展类去加载用户jar包**
- 放入/jre/lib/ext下进行扩展，同样不推荐，尽可能不去更改JDK安装目录中的内容
- 使用参数进行扩展，推荐，使用-Djava.ext.dirs=jar包目录 进行扩展，这种方式会覆盖调原始目录，可以用..追加上原始目录.

### 类加载器的双亲委派机制
由于Java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题

- 双亲委派机制的作用？
1. 保证类加载的安全性： 通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性
2. 避免重复加载：双亲委派机制可以避免同一个类被多次加载

**类加载器的双亲委派机制**  
双亲委派机制指的是：当一个类加载器接受到加载器任务时，会自底向上查找是否加载过，再由顶向下进行加载。  
每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则将加载请求委派给父类加载器。

**父类加载器的小细节**
- 每个Java实现的类加载器中保存了一个成员变量叫"父加载器"，可以理解为它的上级，但并不是继承关系

⭐类的双亲委派机制是什么？面试题
1. 当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载
2. 应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器
3. 双亲委派机制的好处有两点：第一是避免恶意代码替换JDK的核心类库，比如java.lang.String，确保核心类库的完整性和安全性，第二是避免一个类重复地被加载。

## 打破双亲委派机制
1. 自定义类加载器
- 自定义类加载器并且重写loadClass方法，就可以将双亲委派机制的代码去除
- Tomcat通过这种方式实现应用之间的类隔离
2. 线程上下文类加载器
- 利用上下文类加载器加载类，比如JDBC
3. Osgi框架的类加载器

为什么需要打破双亲委派机制？  
- 一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类
- 如果不打破双亲委派机制，当应用类加载器加载web应用的MyServlet之后，第二个就无法被加载了

两个自定义类加载器加载相同限定名的类，不会冲突吗？
- 不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同类限定名才会被认为是同一个类

### 线程上下文类加载器
- 利用上下文类加载器加载类-JDBC案例

JDBC需要用启动类加载DriverManager但是又需要让应用加载类加载驱动，这违背了双亲委托策略。首先我们要解决驱动是怎么知道要加载哪个jar包的？  
SPI机制：
- spi全称为Service Provider Interface，是JDK内置的一种服务提供发现机制
- spi的工作原理：
1. 在ClassPath路径下的META-INF/services文件夹中，以接口的全限定名来命名文件名，对应的文件里面写该接口的实现
2. 使用ServiceLoader加载实现类

SPI是如何拿到应用加载类- 利用了线程上下文类加载器去加载类并创建对象

这里真的打破了吗?其实感觉可以理解为帮找父类了。

打破双亲委派机制的第三种方法：OSGi模块化
- 历史上，OSGi模块化框架，它存在同级之间的类加载器的委托加载，OSGi还使用了类加载器实现了热部署的功能
- 热部署指的是在服务不停止的情况下，动态更新字节码文件到内存中

### JDK8之后的类加载器
- 由于JDK9引入了module的概念，类加载器在设计上发生了很多变化
1. 启动类加载器使用Java编写，位于jdk.internel.loader.ClassLoaders类中。Java中的BootClassLoader继承自BuiltlinClassLoader实现从模块中找到要加载的字节码资源文件。启动类加载依然无法通过java代码获取到，返回的仍然是null，保持了统一。
2. 扩展类加载器被替换成了平台类加载器，平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader编程了BuitlinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计模式兼容，自身没有特殊的逻辑。

### 运行时数据区
- Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区

**运行时数据区可以分为两部分**
1. 线程不共享
- 程序计数器
- Java虚拟机栈
- 本地方法栈
2. 线程共享(可能存在线程安全问题)
- 方法区
- 堆

**面试题**
- Java内存分称几个部分？详细介绍游戏啊
- Java内存中哪些部分会内存溢出
- JDK7和8在内存结构上的区别是什么？

**内存调优学习路线**
1. 了解运行时内存结构，了解JVM运行过程时每一部分的内存结构以及哪些部分容易出现内存溢出
2. 掌握内存问题的产生原因，学习代码中常见的几种内存泄漏性能问题的常见原因
3. 掌握内存调优的基本方法，学习内存泄露，性能问题等常见JVM问题的常规解决方案。

### 程序计数器
- 程序计数器也叫做PC寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址。
- 在代码执行过程中，程序计数器会记录下一行字节码指令的地址，在执行完当前指令后，虚拟机的执行引擎根据程序计数器执行下一行指令
- 在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并解释运行

程序计数器会发生内存溢出吗？显然不会

### Java虚拟机栈
- java虚拟机栈采用栈的数据结构来管理方法调用中的基本数据，先进后出，每一个方法的调用都使用一个栈帧来保存。
- java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行，由于方法可能会在不同的线程中执行，每个线程都会包含一个自己的虚拟栈

###Java虚拟机栈-栈帧的组成
- 局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量
- 操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域
- 栈数据，主要包括动态连接、方法出口、异常表的引用等

**局部变量表**
- 局部变量表的作用是在方法执行过程中存放所有的局部变量，编译成字节码文件时就可以确定局部变量的表的内容。
- 栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽，long和double类型占用两个槽，其他类型占用一个槽。
- 实例方法中的序号为0的位置存放的是this,指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址
- 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致
- 局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量·
 

